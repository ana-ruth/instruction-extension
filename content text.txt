// content.js
// P2's focus: DOM Scraper & Highlighting Logic
// This script runs in the context of the active web page.

/**
 * PHASE 1 & 2: Communication Listener and Handlers
 * Set up the listener to receive and respond to the Service Worker (P3).
 */

// 1. Set up the message listener to receive commands from the service worker (P3)
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    
    // P3 Compatibility Update: P3 sends { action: 'HIGHLIGHT_ELEMENT', selector: '...' }
    if (message.action === 'HIGHLIGHT_ELEMENT' && message.selector) {
        highlightElement(message.selector);
    }
    
    // P3 Compatibility Update: P3 sends { action: 'GET_CONTEXT' }
    if (message.action === 'GET_CONTEXT') {
        // Return the robust context object.
        sendResponse({ context: scrapeContext() });
        return true; // Indicates an asynchronous response (needed for sendResponse)
    }
});


// -----------------------------------------------------------------------------

/**
 * PHASE 2: Robust DOM Context Scraper (Tasks 6-8h)
 * Collects page context for the LLM prompt.
 */
function scrapeContext() {
    const MAX_ELEMENTS = 20; // Limit the number of interactive elements

    const interactiveElements = Array.from(document.querySelectorAll('a, button, input:not([type="hidden"]), textarea'))
        .filter(el => {
            // Only consider visible and enabled elements
            const style = window.getComputedStyle(el);
            return style.display !== 'none' && 
                   style.visibility !== 'hidden' && 
                   !el.disabled;
        })
        .slice(0, MAX_ELEMENTS) 
        .map((el, index) => {
            // Inject a temporary, reliable attribute for the LLM to use
            let selector = `[data-elder-guide-id="${index}"]`;
            el.setAttribute('data-elder-guide-id', index); 

            // Clean up text content for better LLM input
            let text = el.innerText ? el.innerText.trim().substring(0, 50) : el.getAttribute('placeholder') || el.getAttribute('value') || el.getAttribute('aria-label') || '';

            return {
                type: el.tagName.toLowerCase(),
                text: text,
                id: el.id || '',
                selector: selector, // The selector the LLM MUST return
                // xpath: getXPath(el), // Optional but helpful for context
                isClickable: el.tagName === 'A' || el.tagName === 'BUTTON',
            };
        });

    return {
        pageTitle: document.title,
        pageURL: document.URL,
        interactiveElements: interactiveElements
    };
}


/**
 * PHASE 2: Highlighting Logic (Tasks 10-12h)
 * Applies a persistent, high-visibility style to the element.
 * @param {string} selector - The CSS selector for the element to highlight.
 */
function highlightElement(selector) {
    // 1. Clear any previously highlighted elements
    document.querySelectorAll('.elder-guide-highlight').forEach(el => {
        el.classList.remove('elder-guide-highlight');
        el.style.boxShadow = '';
        el.style.outline = '';
        el.style.zIndex = '';
    });

    const targetElement = document.querySelector(selector);

    if (targetElement) {
        // 2. Apply high-visibility styles
        targetElement.classList.add('elder-guide-highlight');
        targetElement.style.boxShadow = '0 0 0 5px #FF5733'; // Bright orange/red shadow
        targetElement.style.outline = '3px solid #C70039'; // Solid outline
        targetElement.style.zIndex = '999999'; // Ensure visibility over page content

        // 3. Scroll the highlighted element into view
        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

        console.log(`Elder-Guide: Successfully highlighted element: ${selector}`);
    } else {
        console.error(`Elder-Guide: Could not find element with selector: ${selector}`);
    }
}

// NOTE: The getXPath utility function from the previous version is omitted for brevity,
// but you can include it if you want the LLM to have XPath context as well.